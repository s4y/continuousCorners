<!DOCTYPE html>
<style>

#settings {
  list-style: none;
  padding: 0 0.5em;
}

li {
  margin: 1em 0;
}

</style>
<ul id=settings></ul>
<p><svg width=400 height=400 viewBox="-1 -1 2 2">
  <!--<rect fill=red rx=1 ry=1 x=0 y=0 width=4 height=4>
    <animate attributeType="CSS" attributeName="opacity" values="1;0;1" dur="2s" repeatCount="indefinite" />
  </rect>-->
  <path id=squircle x=1 fill="rgba(0, 0, 0, 0.7)"/>
</svg></p>

<script>

class Settings {
  constructor(el, onchange) {
    this.el = el;
    this.onchange = onchange;
    this.inputs = Object.create(null);
  }

  toJSON() {
    const ret = {};
    for (const k in this.inputs) {
      ret[k] = this[k];
    }
    return ret;
  }

  appendElement(name, el) {
    const liEl = document.createElement('li');
    const labelEl = document.createElement('label');
    labelEl.appendChild(document.createTextNode(name));
    labelEl.appendChild(document.createElement('br'));
    labelEl.appendChild(el);
    liEl.appendChild(labelEl);
    this.el.appendChild(liEl);
  }

  load() {
    let saved = JSON.parse(sessionStorage.settings);
    for (const k in saved) {
      this[k] = saved[k];
    }
  }

  save() {
    sessionStorage.settings = JSON.stringify(this);
  }

  wantSave() {
    if (this.saveTimeout)
      return;
    this.saveTimeout = createTimeout(() => {
      this.save();
    }, 100);
  }

  addSlider(name, min, max, step, initial) {
    const el = document.createElement('input');
    el.type = 'range';
    el.min = min;
    el.max = max;
    el.step = step;
    el.value = initial;
    el.oninput = e => {
      this.save();
      this.onchange();
    };
    this.inputs[name] = el;
    this.appendElement(name, el);

    Object.defineProperty(this, name, {
      get: () => el.valueAsNumber,
      set: val => { el.valueAsNumber = val; },
    });
    return el;
  }
};

const pathElA = document.getElementById('squircle');
const pathElB = pathElA.cloneNode(true);

const joinPoints = points => {
  return points.map(coord => coord.join(' ')).join(' ');
}

const rotate = ([x, y], θ) => {
  return [
    x * Math.cos(θ) + y * Math.sin(θ),
    -x * Math.sin(θ) + y * Math.cos(θ),
  ];
};

const updateSquircle = ({
  endLocation,
  endVelocity,
  midpointLocation,
  midpointVelocity,
}) => {
  const side = [
    [-1, 0-endLocation-endVelocity],
    [-1, -1+endLocation+endVelocity],
    [-1, -1+endLocation],
  ];
  const cornerA = [
    [
      -1 + midpointLocation + Math.cos(Math.PI * 1.25) * midpointVelocity,
      -1 + midpointLocation + Math.sin(Math.PI * 1.25) * -midpointVelocity
    ],
    [-1 + midpointLocation, -1 + midpointLocation],
  ];
  const cornerB = [
    [-1 + endLocation - endVelocity, -1],
    [-1 + endLocation, -1],
  ];

  pathElA.setAttribute('d', `
    M 0 ${4-endLocation},
    C ${joinPoints(side)},
    S ${joinPoints(cornerA)},
    S ${joinPoints(cornerB)},
    C ${joinPoints(side.map(p => rotate(p, Math.PI * -0.5)))},
    S ${joinPoints(cornerA.map(p => rotate(p, Math.PI * -0.5)))},
    S ${joinPoints(cornerB.map(p => rotate(p, Math.PI * -0.5)))},
    Z`);
  // pathElB.setAttribute('d', `
  //   M 0 1,
  //   C 0 ${params.endVelocity}, ${params.endVelocity} 0, 1 0,
  //   L 1 0,
  //   L 1 1,
  //   L 0 1,
  //   Z`);
}



const settings = new Settings(document.getElementById('settings'), () => {
  updateSquircle(settings);
});

settings.addSlider('endLocation', 0, 1, 0.01, 0.3);
settings.addSlider('endVelocity', 0, 1, 0.01, 0.25);
settings.addSlider('midpointLocation', 0, 1, 0.01, 0.2);
settings.addSlider('midpointVelocity', 0, 1, 0.01, 0.25);
settings.load();

updateSquircle(settings);

</script>

<!--<p><svg width=200 height=200 viewBox="0 0 1 1">
  <rect fill=red rx=.3 ry=.3 x=0 y=0 width=1 height=1>
  <animate attributeType="CSS" attributeName="opacity" values="1;0;1" dur="2s" repeatCount="indefinite" />
  </rect>
  <path id=squircle x=1 fill="rgba(0, 0, 0, 0.7)" d="
    M0 .5,
    C0 .07, .07 0, .5 0,
    C.93 0, 1 .07, 1 .5,
    C1 .93, .93 1, .5 1,
    C.07 1, 0 .93, 0 .5,
    Z"/>
</svg></p>-->
